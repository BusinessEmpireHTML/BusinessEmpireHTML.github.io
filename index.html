<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Universe Explorer & Colony Builder</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: Arial, sans-serif;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="hud">Loading...</div>
  <!-- Three.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    /***************************************
     * Scene, Camera, Renderer & Global Setup
     ***************************************/
    let scene, camera, renderer, clock;
    initScene();

    function initScene(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 10000);
      camera.position.set(0, 50, 200);

      renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      clock = new THREE.Clock();

      // Basic lighting: ambient & directional
      let ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      let directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(100, 100, 100);
      scene.add(directionalLight);

      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /***************************************
     * Universe, Solar Systems, Planets & Colonies
     ***************************************/
    // The Universe class holds many solar systems, each with stars and planets.
    class Universe {
      constructor() {
        this.solarSystems = [];
        // Procedurally generate a few solar systems
        for (let i = 0; i < 5; i++){
          let system = new SolarSystem(i);
          this.solarSystems.push(system);
        }
      }
      update(delta){
        this.solarSystems.forEach(system => system.update(delta));
      }
    }

    // SolarSystem creates a central star and orbits of planets.
    class SolarSystem {
      constructor(id) {
        this.id = id;
        this.planets = [];
        // Create a star for this system at a random location.
        this.star = this.createStar();
        scene.add(this.star);
        // Generate planets (each with unique properties)
        let numPlanets = Math.floor(Math.random() * 5) + 3; // Between 3 and 7 planets
        for (let i = 0; i < numPlanets; i++){
          let angle = Math.random() * Math.PI * 2;
          let distance = 50 + i * 50 + Math.random() * 20;
          let planet = new Planet(distance, angle);
          this.planets.push(planet);
          scene.add(planet.mesh);
        }
      }
      
      createStar(){
        // Star rendered as a glowing yellow sphere.
        let geometry = new THREE.SphereGeometry(10, 32, 32);
        let material = new THREE.MeshBasicMaterial({color: 0xffff00});
        let star = new THREE.Mesh(geometry, material);
        star.position.set((Math.random()-0.5)*500, (Math.random()-0.5)*500, (Math.random()-0.5)*500);
        return star;
      }
      
      update(delta){
        // Update each planet’s orbit.
        this.planets.forEach(planet => planet.update(delta));
      }
    }

    // Planet class defines orbital parameters and properties (habitable vs. hostile, resources, etc.)
    class Planet {
      constructor(distance, angle) {
        this.distance = distance;
        this.angle = angle;
        // Randomly decide habitability (affects color and potential for colony)
        this.habitable = Math.random() > 0.5;
        // Generate random resource quantities
        this.resources = {
          iron: Math.floor(Math.random()*1000),
          titanium: Math.floor(Math.random()*500),
          hydrogen: Math.floor(Math.random()*2000),
          rareCrystals: Math.floor(Math.random()*200)
        };
        // Create a planet mesh – size and color vary based on habitability.
        let geometry = new THREE.SphereGeometry(5 + Math.random()*5, 32, 32);
        let color = this.habitable ? 0x00ff00 : 0xff0000;
        let material = new THREE.MeshLambertMaterial({color: color});
        this.mesh = new THREE.Mesh(geometry, material);
        this.updatePosition();

        // Colony can be built if conditions are met.
        this.colony = null;
      }
      
      updatePosition(){
        // Calculate orbiting position around a central star assumed at the origin.
        let x = this.distance * Math.cos(this.angle);
        let z = this.distance * Math.sin(this.angle);
        this.mesh.position.set(x, 0, z);
      }
      
      update(delta){
        // Advance orbit over time.
        this.angle += delta * 0.1;
        this.updatePosition();
      }
      
      // Method to build a colony on this planet if habitable.
      buildColony(){
        if (this.habitable && !this.colony){
          this.colony = new Colony(this);
        }
      }
    }

    // Colony class for colonization and resource management.
    class Colony {
      constructor(planet) {
        this.planet = planet;
        this.population = 10;
        this.resourceStorage = {iron: 0, titanium: 0, hydrogen: 0, rareCrystals: 0};
        this.buildings = [];
        // Render a colony marker (a small dome) on the planet.
        let geometry = new THREE.SphereGeometry(1.5, 16, 16);
        let material = new THREE.MeshBasicMaterial({color: 0xffffff});
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(planet.mesh.position);
        scene.add(this.mesh);
      }
      
      update(delta){
        // Update logic for resource consumption, growth, etc.
      }
    }

    /***************************************
     * Spaceship & Navigation (Player-controlled)
     ***************************************/
    // Ship class with basic physics properties, thrust controls and upgradeable stats.
    class Ship {
      constructor(){
        // Create a simple cone geometry to represent the ship.
        let geometry = new THREE.ConeGeometry(2, 6, 16);
        let material = new THREE.MeshLambertMaterial({color: 0x00ffff});
        this.mesh = new THREE.Mesh(geometry, material);
        // Rotate so that the ship “points” forward.
        this.mesh.rotation.x = Math.PI/2;
        scene.add(this.mesh);
        
        // Physics properties.
        this.velocity = new THREE.Vector3();
        this.acceleration = new THREE.Vector3();
        this.maxSpeed = 50;
        this.position = this.mesh.position;
        
        // Navigation and upgradeable stats.
        this.fuel = 100;
        this.shields = 100;
      }
      
      update(delta){
        // Update velocity based on applied acceleration.
        this.velocity.add(this.acceleration.clone().multiplyScalar(delta));
        // Limit to maximum speed.
        if (this.velocity.length() > this.maxSpeed){
          this.velocity.setLength(this.maxSpeed);
        }
        // Update position.
        this.position.add(this.velocity.clone().multiplyScalar(delta));
        // Reset acceleration after each update.
        this.acceleration.set(0,0,0);
      }
      
      // Apply thrust in a specified direction.
      applyThrust(direction, power){
        this.acceleration.add(direction.normalize().multiplyScalar(power));
        // Fuel consumption based on thrust.
        this.fuel = Math.max(0, this.fuel - power * 0.1);
      }
    }

    /***************************************
     * Player Input & Controls
     ***************************************/
    const ship = new Ship();
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    let keysPressed = {};
    function onKeyDown(event){
      keysPressed[event.code] = true;
    }
    function onKeyUp(event){
      keysPressed[event.code] = false;
    }

    // Map keys to ship thrust and rotation.
    function processInput(delta){
      // Forward thrust: ArrowUp or W key.
      if(keysPressed['ArrowUp'] || keysPressed['KeyW']){
        // Thrust in the ship's local forward direction.
        let forward = new THREE.Vector3(0,0,-1).applyQuaternion(ship.mesh.quaternion);
        ship.applyThrust(forward, 10);
      }
      // Reverse thrust.
      if(keysPressed['ArrowDown'] || keysPressed['KeyS']){
        let backward = new THREE.Vector3(0,0,1).applyQuaternion(ship.mesh.quaternion);
        ship.applyThrust(backward, 10);
      }
      // Yaw left/right.
      if(keysPressed['ArrowLeft'] || keysPressed['KeyA']){
        ship.mesh.rotation.y += delta;
      }
      if(keysPressed['ArrowRight'] || keysPressed['KeyD']){
        ship.mesh.rotation.y -= delta;
      }
    }

    /***************************************
     * Game World Initialization
     ***************************************/
    // Create the universe (with solar systems, stars, and planets)
    const universe = new Universe();

    // HUD element for displaying ship and game stats.
    const hud = document.getElementById('hud');
    function updateHUD(){
      hud.innerHTML = `Fuel: ${ship.fuel.toFixed(2)} | Shields: ${ship.shields} | Position: (${ship.position.x.toFixed(1)}, ${ship.position.y.toFixed(1)}, ${ship.position.z.toFixed(1)})`;
    }

    /***************************************
     * Main Game Loop
     ***************************************/
    function animate(){
      requestAnimationFrame(animate);
      let delta = clock.getDelta();
      
      processInput(delta);
      ship.update(delta);
      universe.update(delta);
      
      // Update the camera to follow the ship smoothly.
      camera.position.lerp(new THREE.Vector3(ship.position.x, ship.position.y+50, ship.position.z+100), 0.05);
      camera.lookAt(ship.position);
      
      updateHUD();
      renderer.render(scene, camera);
    }
    animate();

    /***************************************
     * Additional Features & Placeholders
     ***************************************/
    // Multiplayer & Persistence:
    //   Integration with Node.js servers and cloud databases (like Firebase or IndexedDB)
    //   would be added here to support real-time multiplayer exploration and persistent game states.

    // AI & NPCs:
    //   NPC ships (pirates, traders, alien factions) can be implemented with similar class structures
    //   and integrated into the game loop with their own behavior patterns.

    // Colony Management & Planetary Landing:
    //   Proximity detection between the ship and a planet would trigger landing events.
    //   A separate UI/scene would be created for detailed colony-building and planetary surface management.

    // Research, Tech Tree, and Dynamic Galactic Events:
    //   A module to handle research progression, terraforming, cosmic events (like supernovae or black hole time dilation),
    //   and custom ship design could be integrated as the game scales.
  </script>
</body>
</html>
